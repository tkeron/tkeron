import { describe, it, expect, spyOn } from "bun:test";
import { build } from "./build";
import { rmSync, existsSync, mkdirSync, writeFileSync, readFileSync } from "fs";
import { join } from "path";
import { getTestResources } from "./test-helpers";

describe("build", () => {

  it("should build HTML with TypeScript and inject bundled script", async () => {
    const { dir } = getTestResources("build-html-with-typescript");
    const TEST_SRC = join(dir, "src");
    const TEST_OUT = join(dir, "web");
    const consoleLogSpy = spyOn(console, "log").mockImplementation(() => {});
    const consoleErrorSpy = spyOn(console, "error").mockImplementation(() => {});

    try {
      mkdirSync(TEST_SRC, { recursive: true });
      const htmlContent = `<!DOCTYPE html>
<html>
<head><title>Test</title></head>
<body>
  <h1>Test</h1>
  <script type="module" src="./index.ts"></script>
</body>
</html>`;

      const tsContent = `const message: string = "hello"; console.log(message);`;

      writeFileSync(join(TEST_SRC, "index.html"), htmlContent);
      writeFileSync(join(TEST_SRC, "index.ts"), tsContent);

      await build({
        sourceDir: TEST_SRC,
        targetDir: TEST_OUT,
      });

      expect(existsSync(join(TEST_OUT, "index.html"))).toBe(true);
      expect(existsSync(join(TEST_OUT, "index.js"))).toBe(true);

      const outputHtml = readFileSync(join(TEST_OUT, "index.html"), "utf-8");
      expect(outputHtml).toContain("index.js");
    } finally {
      consoleLogSpy?.mockRestore();
      consoleErrorSpy?.mockRestore();
      rmSync(dir, { recursive: true, force: true });
    }
  });

  it("should handle multiple HTML files in subdirectories", async () => {
    const { dir } = getTestResources("build-multiple-html-subdirs");
    const TEST_SRC = join(dir, "src");
    const TEST_OUT = join(dir, "web");
    const consoleLogSpy = spyOn(console, "log").mockImplementation(() => {});
    const consoleErrorSpy = spyOn(console, "error").mockImplementation(() => {});

    try {
      mkdirSync(join(TEST_SRC, "section"), { recursive: true });

      const indexHtml = `<!DOCTYPE html>
<html>
<body>
  <h1>Index</h1>
  <script type="module" src="./index.ts"></script>
</body>
</html>`;

      const sectionHtml = `<!DOCTYPE html>
<html>
<body>
  <h1>Section</h1>
  <script type="module" src="./index.ts"></script>
</body>
</html>`;

      writeFileSync(join(TEST_SRC, "index.html"), indexHtml);
      writeFileSync(join(TEST_SRC, "index.ts"), `console.log("main");`);
      writeFileSync(join(TEST_SRC, "section", "index.html"), sectionHtml);
      writeFileSync(join(TEST_SRC, "section", "index.ts"), `console.log("section");`);

      await build({
        sourceDir: TEST_SRC,
        targetDir: TEST_OUT,
      });

      expect(existsSync(join(TEST_OUT, "index.html"))).toBe(true);
      expect(existsSync(join(TEST_OUT, "index.js"))).toBe(true);
      expect(existsSync(join(TEST_OUT, "section", "index.html"))).toBe(true);
      expect(existsSync(join(TEST_OUT, "section", "index.js"))).toBe(true);
    } finally {
      consoleLogSpy?.mockRestore();
      consoleErrorSpy?.mockRestore();
      rmSync(dir, { recursive: true, force: true });
    }
  });

  it("should process .pre.ts files and generate HTML", async () => {
    const { dir } = getTestResources("build-process-pre-ts");
    const TEST_SRC = join(dir, "src");
    const TEST_OUT = join(dir, "web");
    const consoleLogSpy = spyOn(console, "log").mockImplementation(() => {});
    const consoleErrorSpy = spyOn(console, "error").mockImplementation(() => {});

    try {
      mkdirSync(TEST_SRC, { recursive: true });

      const preContent = `
// Modify the document
const h1 = document.createElement("h1");
h1.textContent = "Generated by pre.ts";
document.body.appendChild(h1);
`;

      const htmlContent = `<!DOCTYPE html>
<html>
<head><title>Pre Test</title></head>
<body></body>
</html>`;

      writeFileSync(join(TEST_SRC, "page.pre.ts"), preContent);
      writeFileSync(join(TEST_SRC, "page.html"), htmlContent);

      await build({
        sourceDir: TEST_SRC,
        targetDir: TEST_OUT,
      });

      expect(existsSync(join(TEST_OUT, "page.html"))).toBe(true);
      const outputHtml = readFileSync(join(TEST_OUT, "page.html"), "utf-8");
      expect(outputHtml).toContain("Generated by pre.ts");
    } finally {
      consoleLogSpy?.mockRestore();
      consoleErrorSpy?.mockRestore();
      rmSync(dir, { recursive: true, force: true });
    }
  });

  it("should create default HTML for .pre.ts without corresponding .html", async () => {
    const { dir } = getTestResources("build-pre-ts-default-html");
    const TEST_SRC = join(dir, "src");
    const TEST_OUT = join(dir, "web");
    const consoleLogSpy = spyOn(console, "log").mockImplementation(() => {});
    const consoleErrorSpy = spyOn(console, "error").mockImplementation(() => {});

    try {
      mkdirSync(TEST_SRC, { recursive: true });

      const preContent = `
const title = document.querySelector("title");
if (title) title.textContent = "Auto-generated";
`;

      writeFileSync(join(TEST_SRC, "auto.pre.ts"), preContent);

      await build({
        sourceDir: TEST_SRC,
        targetDir: TEST_OUT,
      });

      expect(existsSync(join(TEST_OUT, "auto.html"))).toBe(true);
      const outputHtml = readFileSync(join(TEST_OUT, "auto.html"), "utf-8");
      expect(outputHtml).toContain("Auto-generated");
    } finally {
      consoleLogSpy?.mockRestore();
      consoleErrorSpy?.mockRestore();
      rmSync(dir, { recursive: true, force: true });
    }
  });

  it("should clean existing target directory before building", async () => {
    const { dir } = getTestResources("build-clean-target-directory");
    const TEST_SRC = join(dir, "src");
    const TEST_OUT = join(dir, "web");
    const consoleLogSpy = spyOn(console, "log").mockImplementation(() => {});
    const consoleErrorSpy = spyOn(console, "error").mockImplementation(() => {});

    try {
      mkdirSync(TEST_SRC, { recursive: true });
      mkdirSync(TEST_OUT, { recursive: true });

      // Create a file in target that shouldn't exist after build
      writeFileSync(join(TEST_OUT, "old-file.txt"), "should be deleted");

      const htmlContent = `<!DOCTYPE html>
<html>
<body>
  <h1>New Build</h1>
  <script type="module" src="./index.ts"></script>
</body>
</html>`;

      writeFileSync(join(TEST_SRC, "index.html"), htmlContent);
      writeFileSync(join(TEST_SRC, "index.ts"), `console.log("new");`);

      await build({
        sourceDir: TEST_SRC,
        targetDir: TEST_OUT,
      });

      expect(existsSync(join(TEST_OUT, "old-file.txt"))).toBe(false);
      expect(existsSync(join(TEST_OUT, "index.html"))).toBe(true);
    } finally {
      consoleLogSpy?.mockRestore();
      consoleErrorSpy?.mockRestore();
      rmSync(dir, { recursive: true, force: true });
    }
  });

  it("should handle HTML without scripts", async () => {
    const { dir } = getTestResources("build-html-without-scripts");
    const TEST_SRC = join(dir, "src");
    const TEST_OUT = join(dir, "web");
    const consoleLogSpy = spyOn(console, "log").mockImplementation(() => {});
    const consoleErrorSpy = spyOn(console, "error").mockImplementation(() => {});

    try {
      mkdirSync(TEST_SRC, { recursive: true });

      const htmlContent = `<!DOCTYPE html>
<html>
<head><title>No Scripts</title></head>
<body>
  <h1>Static HTML</h1>
</body>
</html>`;

      writeFileSync(join(TEST_SRC, "static.html"), htmlContent);

      await build({
        sourceDir: TEST_SRC,
        targetDir: TEST_OUT,
      });

      expect(existsSync(join(TEST_OUT, "static.html"))).toBe(true);
      const outputHtml = readFileSync(join(TEST_OUT, "static.html"), "utf-8");
      expect(outputHtml).toContain("Static HTML");
    } finally {
      consoleLogSpy?.mockRestore();
      consoleErrorSpy?.mockRestore();
      rmSync(dir, { recursive: true, force: true });
    }
  });

  it("should use default directories when not specified", async () => {
    const { dir } = getTestResources("build-default-directories");
    const defaultSrc = join(dir, "websrc");
    const defaultOut = join(dir, "web");
    const consoleLogSpy = spyOn(console, "log").mockImplementation(() => {});
    const consoleErrorSpy = spyOn(console, "error").mockImplementation(() => {});
    
    try {
      mkdirSync(defaultSrc, { recursive: true });

      const htmlContent = `<!DOCTYPE html>
<html>
<body>
  <h1>Default Dirs</h1>
  <script type="module" src="./index.ts"></script>
</body>
</html>`;

      writeFileSync(join(defaultSrc, "index.html"), htmlContent);
      writeFileSync(join(defaultSrc, "index.ts"), `console.log("default");`);

      // Change to dir to test default behavior
      const originalCwd = process.cwd();
      process.chdir(dir);

      try {
        await build({});
        
        expect(existsSync(join(defaultOut, "index.html"))).toBe(true);
        expect(existsSync(join(defaultOut, "index.js"))).toBe(true);
      } finally {
        process.chdir(originalCwd);
      }
    } finally {
      consoleLogSpy?.mockRestore();
      consoleErrorSpy?.mockRestore();
      rmSync(dir, { recursive: true, force: true });
    }
  });

  it("should handle .pre.ts files in subdirectories", async () => {
    const { dir } = getTestResources("build-pre-ts-subdirectories");
    const TEST_SRC = join(dir, "src");
    const TEST_OUT = join(dir, "web");
    const consoleLogSpy = spyOn(console, "log").mockImplementation(() => {});
    const consoleErrorSpy = spyOn(console, "error").mockImplementation(() => {});

    try {
      mkdirSync(join(TEST_SRC, "nested"), { recursive: true });

      const preContent = `
const h2 = document.createElement("h2");
h2.textContent = "Nested Pre";
document.body.appendChild(h2);
`;

      const htmlContent = `<!DOCTYPE html>
<html>
<body><h1>Nested</h1></body>
</html>`;

      writeFileSync(join(TEST_SRC, "nested", "page.pre.ts"), preContent);
      writeFileSync(join(TEST_SRC, "nested", "page.html"), htmlContent);

      await build({
        sourceDir: TEST_SRC,
        targetDir: TEST_OUT,
      });

      expect(existsSync(join(TEST_OUT, "nested", "page.html"))).toBe(true);
      const outputHtml = readFileSync(join(TEST_OUT, "nested", "page.html"), "utf-8");
      expect(outputHtml).toContain("Nested Pre");
    } finally {
      consoleLogSpy?.mockRestore();
      consoleErrorSpy?.mockRestore();
      rmSync(dir, { recursive: true, force: true });
    }
  });
});
