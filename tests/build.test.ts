import { describe, it, expect } from "bun:test";
import { build } from "../src/build";
import {
  cleanupOrphanedTempDirs,
  TEMP_DIR_PREFIX,
} from "../src/cleanupOrphanedTempDirs";
import {
  rmSync,
  existsSync,
  mkdirSync,
  writeFileSync,
  readFileSync,
  readdirSync,
} from "fs";
import { join } from "path";
import { getTestResources, createTestLogger } from "./test-helpers";
describe("build", () => {
  it("should build HTML with TypeScript and inject bundled script", async () => {
    const { dir } = getTestResources("build-html-with-typescript");
    const TEST_SRC = join(dir, "src");
    const TEST_OUT = join(dir, "web");
    try {
      mkdirSync(TEST_SRC, { recursive: true });
      const htmlContent = `<!DOCTYPE html>
<html>
<head><title>Test</title></head>
<body>
  <h1>Test</h1>
  <script type="module" src="./index.ts"></script>
</body>
</html>`;
      const tsContent = `const message: string = "hello"; console.log(message);`;
      writeFileSync(join(TEST_SRC, "index.html"), htmlContent);
      writeFileSync(join(TEST_SRC, "index.ts"), tsContent);
      await build({
        sourceDir: TEST_SRC,
        targetDir: TEST_OUT,
      });
      expect(existsSync(join(TEST_OUT, "index.html"))).toBe(true);
      expect(existsSync(join(TEST_OUT, "index.js"))).toBe(true);
      const outputHtml = readFileSync(join(TEST_OUT, "index.html"), "utf-8");
      expect(outputHtml).toContain("index.js");
    } finally {
      rmSync(dir, { recursive: true, force: true });
    }
  });
  it("should handle multiple HTML files in subdirectories", async () => {
    const { dir } = getTestResources("build-multiple-html-subdirs");
    const TEST_SRC = join(dir, "src");
    const TEST_OUT = join(dir, "web");
    try {
      mkdirSync(join(TEST_SRC, "section"), { recursive: true });
      const indexHtml = `<!DOCTYPE html>
<html>
<body>
  <h1>Index</h1>
  <script type="module" src="./index.ts"></script>
</body>
</html>`;
      const sectionHtml = `<!DOCTYPE html>
<html>
<body>
  <h1>Section</h1>
  <script type="module" src="./index.ts"></script>
</body>
</html>`;
      writeFileSync(join(TEST_SRC, "index.html"), indexHtml);
      writeFileSync(join(TEST_SRC, "index.ts"), `console.log("main");`);
      writeFileSync(join(TEST_SRC, "section", "index.html"), sectionHtml);
      writeFileSync(
        join(TEST_SRC, "section", "index.ts"),
        `console.log("section");`,
      );
      await build({
        sourceDir: TEST_SRC,
        targetDir: TEST_OUT,
      });
      expect(existsSync(join(TEST_OUT, "index.html"))).toBe(true);
      expect(existsSync(join(TEST_OUT, "index.js"))).toBe(true);
      expect(existsSync(join(TEST_OUT, "section", "index.html"))).toBe(true);
      expect(existsSync(join(TEST_OUT, "section", "index.js"))).toBe(true);
    } finally {
      rmSync(dir, { recursive: true, force: true });
    }
  });
  it("should process .pre.ts files and generate HTML", async () => {
    const { dir } = getTestResources("build-process-pre-ts");
    const TEST_SRC = join(dir, "src");
    const TEST_OUT = join(dir, "web");
    try {
      mkdirSync(TEST_SRC, { recursive: true });
      const preContent = `
// Modify the document
const h1 = document.createElement("h1");
h1.textContent = "Generated by pre.ts";
document.body.appendChild(h1);
`;
      const htmlContent = `<!DOCTYPE html>
<html>
<head><title>Pre Test</title></head>
<body></body>
</html>`;
      writeFileSync(join(TEST_SRC, "page.pre.ts"), preContent);
      writeFileSync(join(TEST_SRC, "page.html"), htmlContent);
      await build({
        sourceDir: TEST_SRC,
        targetDir: TEST_OUT,
      });
      expect(existsSync(join(TEST_OUT, "page.html"))).toBe(true);
      const outputHtml = readFileSync(join(TEST_OUT, "page.html"), "utf-8");
      expect(outputHtml).toContain("Generated by pre.ts");
    } finally {
      rmSync(dir, { recursive: true, force: true });
    }
  });
  it("should create default HTML for .pre.ts without corresponding .html", async () => {
    const { dir } = getTestResources("build-pre-ts-default-html");
    const TEST_SRC = join(dir, "src");
    const TEST_OUT = join(dir, "web");
    try {
      mkdirSync(TEST_SRC, { recursive: true });
      const preContent = `
const title = document.querySelector("title");
if (title) title.textContent = "Auto-generated";
`;
      writeFileSync(join(TEST_SRC, "auto.pre.ts"), preContent);
      await build({
        sourceDir: TEST_SRC,
        targetDir: TEST_OUT,
      });
      expect(existsSync(join(TEST_OUT, "auto.html"))).toBe(true);
      const outputHtml = readFileSync(join(TEST_OUT, "auto.html"), "utf-8");
      expect(outputHtml).toContain("Auto-generated");
    } finally {
      rmSync(dir, { recursive: true, force: true });
    }
  });
  it("should clean existing target directory before building", async () => {
    const { dir } = getTestResources("build-clean-target-directory");
    const TEST_SRC = join(dir, "src");
    const TEST_OUT = join(dir, "web");
    try {
      mkdirSync(TEST_SRC, { recursive: true });
      mkdirSync(TEST_OUT, { recursive: true });
      writeFileSync(join(TEST_OUT, "old-file.txt"), "should be deleted");
      const htmlContent = `<!DOCTYPE html>
<html>
<body>
  <h1>New Build</h1>
  <script type="module" src="./index.ts"></script>
</body>
</html>`;
      writeFileSync(join(TEST_SRC, "index.html"), htmlContent);
      writeFileSync(join(TEST_SRC, "index.ts"), `console.log("new");`);
      await build({
        sourceDir: TEST_SRC,
        targetDir: TEST_OUT,
      });
      expect(existsSync(join(TEST_OUT, "old-file.txt"))).toBe(false);
      expect(existsSync(join(TEST_OUT, "index.html"))).toBe(true);
    } finally {
      rmSync(dir, { recursive: true, force: true });
    }
  });
  it("should handle HTML without scripts", async () => {
    const { dir } = getTestResources("build-html-without-scripts");
    const TEST_SRC = join(dir, "src");
    const TEST_OUT = join(dir, "web");
    try {
      mkdirSync(TEST_SRC, { recursive: true });
      const htmlContent = `<!DOCTYPE html>
<html>
<head><title>No Scripts</title></head>
<body>
  <h1>Static HTML</h1>
</body>
</html>`;
      writeFileSync(join(TEST_SRC, "static.html"), htmlContent);
      await build({
        sourceDir: TEST_SRC,
        targetDir: TEST_OUT,
      });
      expect(existsSync(join(TEST_OUT, "static.html"))).toBe(true);
      const outputHtml = readFileSync(join(TEST_OUT, "static.html"), "utf-8");
      expect(outputHtml).toContain("Static HTML");
    } finally {
      rmSync(dir, { recursive: true, force: true });
    }
  });
  it("should use default directories when not specified", async () => {
    const { dir } = getTestResources("build-default-directories");
    const defaultSrc = join(dir, "websrc");
    const defaultOut = join(dir, "web");
    try {
      mkdirSync(defaultSrc, { recursive: true });
      const htmlContent = `<!DOCTYPE html>
<html>
<body>
  <h1>Default Dirs</h1>
  <script type="module" src="./index.ts"></script>
</body>
</html>`;
      writeFileSync(join(defaultSrc, "index.html"), htmlContent);
      writeFileSync(join(defaultSrc, "index.ts"), `console.log("default");`);
      const originalCwd = process.cwd();
      process.chdir(dir);
      try {
        await build({});
        expect(existsSync(join(defaultOut, "index.html"))).toBe(true);
        expect(existsSync(join(defaultOut, "index.js"))).toBe(true);
      } finally {
        process.chdir(originalCwd);
      }
    } finally {
      rmSync(dir, { recursive: true, force: true });
    }
  });
  it("should handle .pre.ts files in subdirectories", async () => {
    const { dir } = getTestResources("build-pre-ts-subdirectories");
    const TEST_SRC = join(dir, "src");
    const TEST_OUT = join(dir, "web");
    try {
      mkdirSync(join(TEST_SRC, "nested"), { recursive: true });
      const preContent = `
const h2 = document.createElement("h2");
h2.textContent = "Nested Pre";
document.body.appendChild(h2);
`;
      const htmlContent = `<!DOCTYPE html>
<html>
<body><h1>Nested</h1></body>
</html>`;
      writeFileSync(join(TEST_SRC, "nested", "page.pre.ts"), preContent);
      writeFileSync(join(TEST_SRC, "nested", "page.html"), htmlContent);
      await build({
        sourceDir: TEST_SRC,
        targetDir: TEST_OUT,
      });
      expect(existsSync(join(TEST_OUT, "nested", "page.html"))).toBe(true);
      const outputHtml = readFileSync(
        join(TEST_OUT, "nested", "page.html"),
        "utf-8",
      );
      expect(outputHtml).toContain("Nested Pre");
    } finally {
      rmSync(dir, { recursive: true, force: true });
    }
  });
  it("should handle error when source directory does not exist", async () => {
    const { dir } = getTestResources("build-source-directory-does-not-exist");
    const TEST_SRC = join(dir, "nonexistent-src");
    const TEST_OUT = join(dir, "web");
    try {
      await expect(async () => {
        await build({
          sourceDir: TEST_SRC,
          targetDir: TEST_OUT,
        });
      }).toThrow();
    } finally {
      rmSync(dir, { recursive: true, force: true });
    }
  });
});
describe("temp directory cleanup", () => {
  it("should cleanup temp directory after successful build", async () => {
    const { dir } = getTestResources("cleanup-temp-after-success");
    const TEST_SRC = join(dir, "src");
    const TEST_OUT = join(dir, "web");
    try {
      mkdirSync(TEST_SRC, { recursive: true });
      const htmlContent = `<!DOCTYPE html>
<html>
<body><h1>Test</h1></body>
</html>`;
      writeFileSync(join(TEST_SRC, "index.html"), htmlContent);
      await build({
        sourceDir: TEST_SRC,
        targetDir: TEST_OUT,
      });
      const parentDir = dir;
      const entries = readdirSync(parentDir);
      const tempDirs = entries.filter((name) =>
        name.startsWith(TEMP_DIR_PREFIX),
      );
      expect(tempDirs).toHaveLength(0);
    } finally {
      rmSync(dir, { recursive: true, force: true });
    }
  });
  it("should cleanup temp directory after build failure", async () => {
    const { dir } = getTestResources("cleanup-temp-after-failure");
    const TEST_SRC = join(dir, "src");
    const TEST_OUT = join(dir, "web");
    try {
      mkdirSync(TEST_SRC, { recursive: true });
      const invalidPreContent = `
// This will cause an error at runtime
throw new Error("Intentional test error");
`;
      writeFileSync(join(TEST_SRC, "error.pre.ts"), invalidPreContent);
      writeFileSync(
        join(TEST_SRC, "error.html"),
        "<!DOCTYPE html><html><body></body></html>",
      );
      try {
        await build({
          sourceDir: TEST_SRC,
          targetDir: TEST_OUT,
        });
      } catch (error) {}

      const parentDir = dir;
      const entries = readdirSync(parentDir);
      const tempDirs = entries.filter((name) =>
        name.startsWith(TEMP_DIR_PREFIX),
      );
      expect(tempDirs).toHaveLength(0);
    } finally {
      rmSync(dir, { recursive: true, force: true });
    }
  });
  it("should cleanup orphaned temp directories from previous failed builds", async () => {
    const { dir } = getTestResources("cleanup-orphaned-temp-dirs");
    const TEST_SRC = join(dir, "src");
    const TEST_OUT = join(dir, "web");
    try {
      mkdirSync(TEST_SRC, { recursive: true });
      const orphan1 = join(dir, `${TEMP_DIR_PREFIX}orphan-uuid-1`);
      const orphan2 = join(dir, `${TEMP_DIR_PREFIX}orphan-uuid-2`);
      mkdirSync(orphan1, { recursive: true });
      mkdirSync(orphan2, { recursive: true });
      writeFileSync(join(orphan1, "leftover.txt"), "leftover content");
      expect(existsSync(orphan1)).toBe(true);
      expect(existsSync(orphan2)).toBe(true);
      const htmlContent = `<!DOCTYPE html>
<html>
<body><h1>Test</h1></body>
</html>`;
      writeFileSync(join(TEST_SRC, "index.html"), htmlContent);
      await build({
        sourceDir: TEST_SRC,
        targetDir: TEST_OUT,
      });
      expect(existsSync(orphan1)).toBe(false);
      expect(existsSync(orphan2)).toBe(false);
      const entries = readdirSync(dir);
      const tempDirs = entries.filter((name) =>
        name.startsWith(TEMP_DIR_PREFIX),
      );
      expect(tempDirs).toHaveLength(0);
    } finally {
      rmSync(dir, { recursive: true, force: true });
    }
  });
  it("should not delete non-temp directories during cleanup", async () => {
    const { dir } = getTestResources("preserve-non-temp-dirs");
    const TEST_SRC = join(dir, "src");
    const TEST_OUT = join(dir, "web");
    try {
      mkdirSync(TEST_SRC, { recursive: true });
      const regularDir = join(dir, "my-regular-folder");
      const dotDir = join(dir, ".hidden-folder");
      const similarNameDir = join(dir, "tktmp-but-no-underscore");
      mkdirSync(regularDir, { recursive: true });
      mkdirSync(dotDir, { recursive: true });
      mkdirSync(similarNameDir, { recursive: true });
      const htmlContent = `<!DOCTYPE html>
<html>
<body><h1>Test</h1></body>
</html>`;
      writeFileSync(join(TEST_SRC, "index.html"), htmlContent);
      await build({
        sourceDir: TEST_SRC,
        targetDir: TEST_OUT,
      });
      expect(existsSync(regularDir)).toBe(true);
      expect(existsSync(dotDir)).toBe(true);
      expect(existsSync(similarNameDir)).toBe(true);
    } finally {
      rmSync(dir, { recursive: true, force: true });
    }
  });
  it("cleanupOrphanedTempDirs should handle empty directory", async () => {
    const { dir } = getTestResources("cleanup-empty-dir");
    try {
      mkdirSync(dir, { recursive: true });
      const { logger } = createTestLogger();
      await cleanupOrphanedTempDirs(dir, logger);
      expect(existsSync(dir)).toBe(true);
    } finally {
      rmSync(dir, { recursive: true, force: true });
    }
  });
  it("cleanupOrphanedTempDirs should handle non-existent directory gracefully", async () => {
    const { dir } = getTestResources("cleanup-nonexistent-dir");
    const nonExistentDir = join(dir, "does-not-exist");
    const { logger } = createTestLogger();
    await cleanupOrphanedTempDirs(nonExistentDir, logger);
  });
  it("cleanupOrphanedTempDirs should only remove directories, not files", async () => {
    const { dir } = getTestResources("cleanup-only-dirs");
    try {
      mkdirSync(dir, { recursive: true });
      const tempFile = join(dir, `${TEMP_DIR_PREFIX}some-file.txt`);
      writeFileSync(tempFile, "file content");
      const tempDir = join(dir, `${TEMP_DIR_PREFIX}some-dir`);
      mkdirSync(tempDir, { recursive: true });
      const { logger } = createTestLogger();
      await cleanupOrphanedTempDirs(dir, logger);
      expect(existsSync(tempFile)).toBe(true);
      expect(existsSync(tempDir)).toBe(false);
    } finally {
      rmSync(dir, { recursive: true, force: true });
    }
  });
  it("should use correct temp directory prefix", () => {
    expect(TEMP_DIR_PREFIX).toBe(".tktmp_build-");
  });

  it("should cleanup temp directory when processPre throws", async () => {
    const { dir } = getTestResources("cleanup-on-processPre-failure");
    const TEST_SRC = join(dir, "src");
    const TEST_OUT = join(dir, "web");
    try {
      mkdirSync(TEST_SRC, { recursive: true });
      writeFileSync(
        join(TEST_SRC, "fail.pre.ts"),
        `throw new Error("processPre catastrophic failure");`,
      );
      writeFileSync(
        join(TEST_SRC, "fail.html"),
        "<!DOCTYPE html><html><body></body></html>",
      );

      try {
        await build({ sourceDir: TEST_SRC, targetDir: TEST_OUT });
      } catch (e) {}

      const entries = readdirSync(dir);
      const tempDirs = entries.filter((name) =>
        name.startsWith(TEMP_DIR_PREFIX),
      );
      expect(tempDirs).toHaveLength(0);
    } finally {
      rmSync(dir, { recursive: true, force: true });
    }
  });

  it("should cleanup temp directory when processCom throws circular dependency error", async () => {
    const { dir } = getTestResources("cleanup-on-processCom-circular");
    const TEST_SRC = join(dir, "src");
    const TEST_OUT = join(dir, "web");
    try {
      mkdirSync(TEST_SRC, { recursive: true });
      writeFileSync(
        join(TEST_SRC, "index.html"),
        `<!DOCTYPE html><html><body><comp-a></comp-a></body></html>`,
      );
      writeFileSync(
        join(TEST_SRC, "comp-a.com.html"),
        `<div><comp-b></comp-b></div>`,
      );
      writeFileSync(
        join(TEST_SRC, "comp-b.com.html"),
        `<div><comp-a></comp-a></div>`,
      );

      try {
        await build({ sourceDir: TEST_SRC, targetDir: TEST_OUT });
      } catch (e) {}

      const entries = readdirSync(dir);
      const tempDirs = entries.filter((name) =>
        name.startsWith(TEMP_DIR_PREFIX),
      );
      expect(tempDirs).toHaveLength(0);
    } finally {
      rmSync(dir, { recursive: true, force: true });
    }
  });

  it("should cleanup temp directory when processComTs throws runtime error", async () => {
    const { dir } = getTestResources("cleanup-on-processComTs-failure");
    const TEST_SRC = join(dir, "src");
    const TEST_OUT = join(dir, "web");
    try {
      mkdirSync(TEST_SRC, { recursive: true });
      writeFileSync(
        join(TEST_SRC, "index.html"),
        `<!DOCTYPE html><html><body><bad-comp></bad-comp></body></html>`,
      );
      writeFileSync(
        join(TEST_SRC, "bad-comp.com.ts"),
        `throw new Error("processComTs catastrophic failure");`,
      );

      try {
        await build({ sourceDir: TEST_SRC, targetDir: TEST_OUT });
      } catch (e) {}

      const entries = readdirSync(dir);
      const tempDirs = entries.filter((name) =>
        name.startsWith(TEMP_DIR_PREFIX),
      );
      expect(tempDirs).toHaveLength(0);
    } finally {
      rmSync(dir, { recursive: true, force: true });
    }
  });

  it("should cleanup temp directory when buildDir fails due to invalid output path", async () => {
    const { dir } = getTestResources("cleanup-on-buildDir-failure");
    const TEST_SRC = join(dir, "src");
    const TEST_OUT = "/dev/null/impossible/path";
    try {
      mkdirSync(TEST_SRC, { recursive: true });
      writeFileSync(
        join(TEST_SRC, "index.html"),
        `<!DOCTYPE html><html><body><h1>Test</h1></body></html>`,
      );

      try {
        await build({ sourceDir: TEST_SRC, targetDir: TEST_OUT });
      } catch (e) {}

      const entries = readdirSync(dir);
      const tempDirs = entries.filter((name) =>
        name.startsWith(TEMP_DIR_PREFIX),
      );
      expect(tempDirs).toHaveLength(0);
    } finally {
      rmSync(dir, { recursive: true, force: true });
    }
  });

  it("should cleanup temp directory when multiple iterations cause MAX_ITERATIONS to be reached", async () => {
    const { dir } = getTestResources("cleanup-on-max-iterations");
    const TEST_SRC = join(dir, "src");
    const TEST_OUT = join(dir, "web");
    try {
      mkdirSync(TEST_SRC, { recursive: true });
      writeFileSync(
        join(TEST_SRC, "index.html"),
        `<!DOCTYPE html><html><body><level-0></level-0></body></html>`,
      );

      for (let i = 0; i < 12; i++) {
        writeFileSync(
          join(TEST_SRC, `level-${i}.com.html`),
          `<div>Level ${i}<level-${i + 1}></level-${i + 1}></div>`,
        );
      }
      writeFileSync(join(TEST_SRC, `level-12.com.html`), `<div>Final</div>`);

      await build({ sourceDir: TEST_SRC, targetDir: TEST_OUT });

      const entries = readdirSync(dir);
      const tempDirs = entries.filter((name) =>
        name.startsWith(TEMP_DIR_PREFIX),
      );
      expect(tempDirs).toHaveLength(0);
    } finally {
      rmSync(dir, { recursive: true, force: true });
    }
  });

  it("should cleanup temp directory when .com.ts has syntax error", async () => {
    const { dir } = getTestResources("cleanup-on-comts-syntax-error");
    const TEST_SRC = join(dir, "src");
    const TEST_OUT = join(dir, "web");
    try {
      mkdirSync(TEST_SRC, { recursive: true });
      writeFileSync(
        join(TEST_SRC, "index.html"),
        `<!DOCTYPE html><html><body><syntax-err></syntax-err></body></html>`,
      );
      writeFileSync(
        join(TEST_SRC, "syntax-err.com.ts"),
        `com.innerHTML = {{{ invalid syntax`,
      );

      try {
        await build({ sourceDir: TEST_SRC, targetDir: TEST_OUT });
      } catch (e) {}

      const entries = readdirSync(dir);
      const tempDirs = entries.filter((name) =>
        name.startsWith(TEMP_DIR_PREFIX),
      );
      expect(tempDirs).toHaveLength(0);
    } finally {
      rmSync(dir, { recursive: true, force: true });
    }
  });

  it("should cleanup temp directory when .pre.ts has import resolution failure", async () => {
    const { dir } = getTestResources("cleanup-on-import-failure");
    const TEST_SRC = join(dir, "src");
    const TEST_OUT = join(dir, "web");
    try {
      mkdirSync(TEST_SRC, { recursive: true });
      writeFileSync(
        join(TEST_SRC, "import-fail.pre.ts"),
        `import { nonexistent } from "./does-not-exist";`,
      );
      writeFileSync(
        join(TEST_SRC, "import-fail.html"),
        "<!DOCTYPE html><html><body></body></html>",
      );

      try {
        await build({ sourceDir: TEST_SRC, targetDir: TEST_OUT });
      } catch (e) {}

      const entries = readdirSync(dir);
      const tempDirs = entries.filter((name) =>
        name.startsWith(TEMP_DIR_PREFIX),
      );
      expect(tempDirs).toHaveLength(0);
    } finally {
      rmSync(dir, { recursive: true, force: true });
    }
  });

  it("should handle warning when cleanup fails", async () => {
    const { dir } = getTestResources("cleanup-warning-on-failure");
    const TEST_SRC = join(dir, "src");
    const TEST_OUT = join(dir, "web");
    const { logger } = createTestLogger();
    try {
      mkdirSync(TEST_SRC, { recursive: true });
      writeFileSync(
        join(TEST_SRC, "index.html"),
        "<!DOCTYPE html><html><body>Test</body></html>",
      );

      await build({ sourceDir: TEST_SRC, targetDir: TEST_OUT, logger });

      expect(existsSync(join(TEST_OUT, "index.html"))).toBe(true);
    } finally {
      rmSync(dir, { recursive: true, force: true });
    }
  });

  it("should log warning when cleanup of orphaned temp directory fails", async () => {
    const { dir } = getTestResources("orphan-cleanup-warning");
    const TEST_SRC = join(dir, "src");
    const TEST_OUT = join(dir, "web");
    const { logger, logs } = createTestLogger();
    try {
      mkdirSync(TEST_SRC, { recursive: true });
      writeFileSync(
        join(TEST_SRC, "index.html"),
        "<!DOCTYPE html><html><body>Test</body></html>",
      );

      const orphanedTempDir = join(dir, `${TEMP_DIR_PREFIX}orphaned-test`);
      mkdirSync(orphanedTempDir, { recursive: true });

      await build({ sourceDir: TEST_SRC, targetDir: TEST_OUT, logger });

      expect(existsSync(join(TEST_OUT, "index.html"))).toBe(true);
      expect(
        logs.some((l) => l.includes("Cleaned up orphaned temp directory")),
      ).toBe(true);
    } finally {
      rmSync(dir, { recursive: true, force: true });
    }
  });
});
